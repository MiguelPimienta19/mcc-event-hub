MCC Event Hub: Technical Architecture
Status: Active Development Goal: Production-ready Event Management System + "Hired in 2026" Portfolio Stack: Next.js (Vercel) + FastAPI (Render/AWS) + Postgres (Supabase)
1. The "Senior" Tech Stack (2026 Edition)
This stack is chosen to maximize employability (Python + React) while ensuring stability for users.
Layer
Technology
Why this gets you hired
Frontend
Next.js (App Router)
Server Components for SEO (Public Events). Client Components for Interactivity (Admin/Chat).
Styling
Tailwind CSS
Proves you can build responsive, mobile-first Design Systems without relying on heavy legacy frameworks like Bootstrap.
Backend
FastAPI (Python)
Proven ability to build Type-Safe Microservices. Aligns with high-paying Data/AI roles.
Database
PostgreSQL (Supabase)
Industry standard Relational DB. Shows you understand SQL & Schema Design, while leveraging Supabase for Auth/Realtime.
Infrastructure
Docker (Backend Only)
"Containerization" is the #1 skill gap for new grads. You are closing it.
Deployment
Hybrid Cloud
Vercel (Frontend) + Render/AWS (Backend). Shows you understand distributed systems.

2. The "Monorepo" Folder Structure
Repository Name: mcc-event-hub
/mcc-event-hub
│
├── /frontend                   # MOVED from your existing 'mcc-web' repo
│   ├── /app
│   │   ├── /events             # Server Components (SEO)
│   │   └── /admin              # Client Components (Interactive)
│   ├── .env.local              # Contains: NEXT_PUBLIC_API_URL=http://localhost:8000
│   ├── tailwind.config.js      # Styling Configuration
│   └── package.json
│
├── /backend                    # NEW FastAPI Service (Run via Docker)
│   ├── /app
│   │   ├── main.py             # Entry Point & CORS
│   │   ├── /routers            # API Endpoints (Move your OpenAI logic here)
│   │   └── /models             # Pydantic Schemas
│   ├── Dockerfile              # REQUIRED for Render/AWS deployment
│   └── requirements.txt
│
├── docker-compose.yml          # Runs Backend + DB locally
└── README.md

3. Migration Strategy (From "mcc-web" to "Senior Monorepo")
Since you already have a working Next.js app, follow these steps to upgrade it:
Create the Monorepo: Make a new folder mcc-event-hub.
Move Frontend: Drag all the files from your current mcc-web repo into the /frontend folder.
Create Backend: Create the /backend folder and set up the FastAPI files.
Refactor API Routes:
Current: You likely have Next.js API routes (e.g., pages/api/chat.ts) calling OpenAI.
New: Move that logic to backend/app/routers/chat.py.
Benefit: Python handles AI libraries (like LangChain/OpenAI) much better than Node.js.
Connect them: Update your Frontend to fetch from the new Python API instead of its own internal API.
4. The "Solid" Engineering Checklist (De-Junior Yourself)
A. Secure Cross-Origin Communication (CORS)
The Problem: Your frontend runs on vercel.app, your backend runs on onrender.com. Browsers block this by default. The Senior Fix: Configure Middleware in backend/app/main.py.
# backend/app/main.py
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware


app = FastAPI()


origins = [
    "http://localhost:3000",          # Local Development
    "[https://mcc-events.vercel.app](https://mcc-events.vercel.app)"   # Production Frontend
]


app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

B. Environment Variable Management
The Problem: You cannot hardcode URLs. The Senior Fix:
Create .env.local in /frontend with: NEXT_PUBLIC_API_URL=http://localhost:8000
In Vercel Settings, set: NEXT_PUBLIC_API_URL=https://mcc-backend.onrender.com
Usage in Code:
const API_URL = process.env.NEXT_PUBLIC_API_URL;
await fetch(`${API_URL}/events`);


5. The Deployment Strategy (Cost: $0/mo)
Phase 1: Production (For the Club)
Frontend: Deploy /frontend folder to Vercel (Hobby Tier).
Backend: Deploy /backend folder to Render (Free Web Service).
Critical Step: Use UptimeRobot to ping your Render URL every 5 minutes so it doesn't "sleep."
Database: Supabase Free Tier.
Note: The free database pauses after 1 week of inactivity. You can simply unpause it in the dashboard if that happens.
Phase 2: The Resume Flex (Staging)
Once the app is working, take one weekend to deploy the Backend Docker Container to an AWS EC2 (t2.micro) instance.
Why: This allows you to put "AWS Infrastructure" on your resume truthfully.
Cost Control: Keep the instance STOPPED when you aren't showing it to a recruiter.
6. The "Zero-Bloat" Docker Compose
We removed the frontend from here. This file now strictly manages your Backend API and Local Database.
Save as: docker-compose.yml
version: '3.8'


services:
  # 1. The Brains (Python API)
  # We containerize this to match Production (Render/AWS) exactly.
  backend:
    build: ./backend
    command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload
    ports:
      - "8000:8000"
    volumes:
      - ./backend:/app  # Live code updates (Hot Reload)
    environment:
      # Connects to the "db" service defined below
      DATABASE_URL: postgresql://postgres:password@db:5432/mcc_db
    depends_on:
      - db


  # 2. The Memory (Local Database)
  # Runs Postgres locally so you don't break the live Supabase DB while testing.
  db:
    image: postgres:15
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_DB: mcc_db
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data


volumes:
  postgres_data:

































